(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{392:function(t,a,s){"use strict";s.r(a);var _=s(25),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 🌵 网络")]),t._v(" "),a("h2",{attrs:{id:"_001-什么是跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_001-什么是跨域"}},[t._v("#")]),t._v(" 001： 什么是跨域？")]),t._v(" "),a("h2",{attrs:{id:"_003-xss-和-cors-攻击-怎么处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_003-xss-和-cors-攻击-怎么处理"}},[t._v("#")]),t._v(" 003： XSS 和 CORS 攻击，怎么处理？")]),t._v(" "),a("h2",{attrs:{id:"_004-session、cookie、sessionstorage、localstorage-的区别。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_004-session、cookie、sessionstorage、localstorage-的区别。"}},[t._v("#")]),t._v(" 004： session、cookie、sessionStorage、localStorage 的区别。")]),t._v(" "),a("h2",{attrs:{id:"_005-当-cookie-被浏览器禁用时-怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_005-当-cookie-被浏览器禁用时-怎么解决"}},[t._v("#")]),t._v(" 005： 当 cookie 被浏览器禁用时，怎么解决？")]),t._v(" "),a("h2",{attrs:{id:"_006-单点登陆如何获取跨站的-cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_006-单点登陆如何获取跨站的-cookie"}},[t._v("#")]),t._v(" 006： 单点登陆如何获取跨站的 Cookie？")]),t._v(" "),a("h2",{attrs:{id:"_007-tcp-和-udp-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_007-tcp-和-udp-区别"}},[t._v("#")]),t._v(" 007： TCP 和 UDP 区别")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("TCP 是面向有连接、提供可靠的、基于字节流的数据传输服务；UDP 则是面向无连接、尽最大能力交付、基于数据报的非可靠数据传输服务；")])]),t._v(" "),a("p",[t._v("TCP 传输数据之前需要进行连接，而 UDP 则无需连接即刻传输数据；也因此 TCP 只支持一对一的数据传输，而 UDP 可以支持一对一、一对多和多对多的传输。")]),t._v(" "),a("p",[t._v("TCP 有拥塞控制和流量控制机制，当意识到丢包或者网络不好时，根据情况来调整发包速度，保证数据传输的安全性；UDP 则没有复杂的控制机制，即使网络拥堵了也不会影响发送速率。")]),t._v(" "),a("p",[t._v("TCP 是基于字节流进行数据传输，发送的时候发的是一个流，即消息是「没有边界」的，消息多大都可以进行传输。并且引入"),a("strong",[t._v("数据包排序机制")]),t._v("来保证消息是有序的，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃；"),a("br"),t._v("\nUDP 则是基于数据报，一个包一个包的发送。")]),t._v(" "),a("p",[t._v("TCP 协议头部包含了源端口号（16 位）、目标端口号（16 位）、序列号（32 位）、确认应答号（32 位）、控制位（SYN、ACK、FIN、RST）、窗口大小（16 位）、校验和（16 位）、紧急指针（16 位）；"),a("br"),t._v("\nUDP 协议非常简单，头部只有 8 个字节（ 64 位），分别包括源端口号（16 位）、目标端口号（16 位）、包长度（16 位）、校验和（16 位）。")])])]),t._v(" "),a("h2",{attrs:{id:"_008-tcp-三次握手-tcp-四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_008-tcp-三次握手-tcp-四次挥手"}},[t._v("#")]),t._v(" 008： TCP 三次握手 / TCP 四次挥手")]),t._v(" "),a("h2",{attrs:{id:"_009-get-和-post-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_009-get-和-post-区别"}},[t._v("#")]),t._v(" 009： GET 和 POST 区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("GET：\b 会暴露请求参数、幂等、结果会被浏览器缓存、产生一个 TCP 数据包、产生一个 TCP 数据包")])]),t._v(" "),a("li",[a("p",[t._v("POST：不会暴露参数（安全性较高）、非幂等、结果不会被浏览器缓存、产生两个 TCP 数据包（先发送 header、100 后继续发送 body）")])])]),t._v(" "),a("h2",{attrs:{id:"_010-http-2-0-升级点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_010-http-2-0-升级点"}},[t._v("#")]),t._v(" 010： HTTP/2.0 升级点")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("头部压缩：采用 HPACK 算法压缩头部，在客户端和服务器同时维护一张头部信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，用于提高速度。")])]),t._v(" "),a("li",[a("p",[t._v("采用二进制格式：头部信息和数据体统称为帧（frame）：头信息帧和数据帧，增加数据传输速率。")])]),t._v(" "),a("li",[a("p",[t._v("可以指定数据流（每个请求的所有数据包）的优先级。")])]),t._v(" "),a("li",[a("p",[t._v("多路复用：可以一个连接中进行多个请求/响应，而不用按顺序一个个进行响应，降低延迟和提高连接利用率。")])]),t._v(" "),a("li",[a("p",[t._v("可以服务端主动推送：当客户端请求 X 资源，服务端知道 X 资源依赖 Y 资源，可提前把 Y 资源推送给客户端进行缓存。")])])]),t._v(" "),a("h2",{attrs:{id:"_011-http-状态码-301、302-303-307-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_011-http-状态码-301、302-303-307-区别"}},[t._v("#")]),t._v(" 011： HTTP 状态码 301、302/303/307 区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("3XX 代表重定向，301 代表永久重定向，302/303/307 则都是代表临时重定向；")])]),t._v(" "),a("li",[a("p",[t._v("302 是 HTTP/1.0 版本规定的，当请求是 GET 时，浏览器会自动重定向至响应头的 Location 字段值；其他请求方式需根据浏览器标准先向用户确认再进行重定向，禁止自动转换方法进行重定向；")])]),t._v(" "),a("li",[a("p",[t._v("303/307 是 HTTP/1.1 版本规定的，当 303 时，浏览器会以 GET 的方式自动重定向至指定 Location；而 307 效果和 302 一致，禁止自动重定向。")])])]),t._v(" "),a("h2",{attrs:{id:"_012-301-和-302-对-seo-的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_012-301-和-302-对-seo-的影响"}},[t._v("#")]),t._v(" 012： 301 和 302 对 SEO 的影响")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("301 意味着网站迁移，需要正确告诉搜索引擎，并且将旧网站完整迁移至新网站，这样子才会减少对 SEO 权重、排名、流量等产生大影响；")])]),t._v(" "),a("li",[a("p",[t._v("302 暂时性跳转，并不会将旧网站的收录、排名、权重、流量等转移到新网站，因此使用 302 跳转，旧网站的排名都不会有太大波动。")])])]),t._v(" "),a("h2",{attrs:{id:"_013-http-缓存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_013-http-缓存机制"}},[t._v("#")]),t._v(" 013： HTTP 缓存机制")]),t._v(" "),a("h4",{attrs:{id:"etag-和-last-modified-的优缺点、分别适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#etag-和-last-modified-的优缺点、分别适用场景"}},[t._v("#")]),t._v(" ETag 和 Last-Modified 的优缺点、分别适用场景")]),t._v(" "),a("h2",{attrs:{id:"_014-http-和-https-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_014-http-和-https-区别"}},[t._v("#")]),t._v(" 014： HTTP 和 HTTPS 区别")]),t._v(" "),a("p",[t._v("HTTP 特性：默认端口 80、明文传输、不进行任何加密、无连接（每次连接只处理一个请求）、无状态（对事务处理没有记忆、上下文请求关系需带上状态）。")]),t._v(" "),a("p",[t._v("HTTPS 特性："),a("br"),t._v("\n（1）默认端口 443 ；"),a("br"),t._v("\n（2）在 HTTP 基础上通过 SSL/TLS 进行加密，涉及 CA 数字证书，安全性更好；"),a("br"),t._v("\n（3）涉及大量的密钥算法计算，需要消耗大量的 CPU 资源。")]),t._v(" "),a("h2",{attrs:{id:"_015-https-如何保证安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_015-https-如何保证安全"}},[t._v("#")]),t._v(" 015： HTTPS 如何保证安全")]),t._v(" "),a("p",[t._v("HTTPS 主要解决三个安全问题：内容隐私、防篡改、确认对方身份。")]),t._v(" "),a("p",[t._v("HTTPS 有握手过程，通过对称加密和非对称加密的方式生成私有密钥，然后进行数据传输，保证数据的防篡改；同时也会在握手过程中，验证数字证书，确保对方身份的合法性和真实性，防止中间人无法通过伪造证书方式进行攻击。")]),t._v(" "),a("h2",{attrs:{id:"_016-tls-握手过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_016-tls-握手过程"}},[t._v("#")]),t._v(" 016：TLS 握手过程")]),t._v(" "),a("h4",{attrs:{id:"tls1-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tls1-2"}},[t._v("#")]),t._v(" TLS1.2")]),t._v(" "),a("h4",{attrs:{id:"tls1-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tls1-3"}},[t._v("#")]),t._v(" TLS1.3")]),t._v(" "),a("h2",{attrs:{id:"_017-简单请求和复杂请求的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_017-简单请求和复杂请求的区别"}},[t._v("#")]),t._v(" 017： 简单请求和复杂请求的区别")]),t._v(" "),a("p",[t._v("简单请求和复杂请求是在 CORS 跨域资源共享的情况下对 http 请求作出的两大分类，主要区别是是否会触发浏览器的 OPTIONS 预检请求。")]),t._v(" "),a("p",[t._v("简单请求是指请求方法是 GET/POST/HEAD、content-type 是 text/plain、form-data、form-urlencoded、且没有自定义头部字段的请求；除此之外都是复杂请求。")]),t._v(" "),a("p",[t._v("跨域资源的处理原理是：浏览器对复杂请求会先触发预检请求，会先发送 OPTIONS 请求服务器是否支持该站点的跨域资源访问，得到服务器答复后，才会将真正的请求发送给服务器。（access-control-allow-origin、access-control-allow-methods）")]),t._v(" "),a("h2",{attrs:{id:"_018-cdn-是什么-以及应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_018-cdn-是什么-以及应用场景"}},[t._v("#")]),t._v(" 018: CDN 是什么，以及应用场景")]),t._v(" "),a("p",[t._v("内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。")]),t._v(" "),a("h2",{attrs:{id:"_019-从网卡把数据包传输出去到服务器发生了什么-osi-参考模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_019-从网卡把数据包传输出去到服务器发生了什么-osi-参考模型"}},[t._v("#")]),t._v(" 019：从网卡把数据包传输出去到服务器发生了什么（OSI 参考模型）")])])}),[],!1,null,null,null);a.default=r.exports}}]);