(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{347:function(t,s,n){"use strict";n.r(s);var a=n(25),e=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"遍历和递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历和递归"}},[t._v("#")]),t._v(" 👉 遍历和递归")]),t._v(" "),s("h2",{attrs:{id:"遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[t._v("#")]),t._v(" 遍历")]),t._v(" "),s("h3",{attrs:{id:"二叉树的遍历方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历方式"}},[t._v("#")]),t._v(" 二叉树的遍历方式")]),t._v(" "),s("ol",[s("li",[t._v("按照顺序规则方式")])]),t._v(" "),s("p",[t._v("先序遍历（preorder）：根->左->右"),s("br"),t._v("\n中序遍历（inorder）：左->根->右"),s("br"),t._v("\n后序遍历（postorder）：左->右->根"),s("br"),t._v("\n层次遍历：扫描式")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("按照实现规则方式")])]),t._v(" "),s("p",[t._v("递归遍历（先、中、后序遍历）"),s("br"),t._v("\n迭代遍历（层次遍历）")]),t._v(" "),s("h3",{attrs:{id:"深度优先搜索-dfs-先序遍历-栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-dfs-先序遍历-栈"}},[t._v("#")]),t._v(" 深度优先搜索 DFS （先序遍历+栈）")]),t._v(" "),s("p",[t._v("DFS 是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("DFS 的特点是试图"),s("strong",[t._v("穷举")]),t._v("所有完整的路径，往往会使用"),s("strong",[t._v("递归来模拟入栈和出栈")]),t._v("的过程。")])]),t._v(" "),s("li",[s("p",[t._v("二叉树的先序遍历正是深度优先搜索思想的递归实现。可以说深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广。")])]),t._v(" "),s("li",[s("p",[t._v("DFS 的本质为栈")])])]),t._v(" "),s("p",[t._v("1） 函数调用底层由栈实现："),s("br"),t._v("\n函数调用的上下文就会被 push 进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被 pop 出来。")]),t._v(" "),s("p",[t._v("2）DFS 作为一种思想，它和树的递归遍历一脉相承、却并不能完全地画上等号——DFS 的解题场景其实有很多，其中有一类会要求我们记录每一层递归式里路径的状态，此时就会强依赖栈结构。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DFS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("root")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 边界情况停止递归")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归式")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"广度优先搜索-bfs-层次遍历-队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-bfs-层次遍历-队列"}},[t._v("#")]),t._v(" 广度优先搜索 BFS （层次遍历+队列）")]),t._v(" "),s("p",[t._v("广度优先遍历是从根节点开始，沿着图的宽度遍历节点，如果所有的节点均被访问过，则算法终止。")]),t._v(" "),s("p",[t._v("BFS 着重关注眼下自己能够直接到达的所有坐标，而非 DFS 的“不撞南墙不回头”。")]),t._v(" "),s("p",[t._v("BFS 的核心思想和"),s("strong",[t._v("二叉树的层次遍历")]),t._v("类似，而其中会有两个规律：")]),t._v(" "),s("p",[t._v("1）每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。"),s("br"),t._v("\n2）站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。")]),t._v(" "),s("p",[t._v("丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，因此整个 BFS 算法的实现过程，和"),s("strong",[t._v("队列")]),t._v("有着密不可分的关系。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("BFS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("root")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化队列queue")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" queue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根结点先入队")]),t._v("\n    queue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("queue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 取出队头")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" top "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" queue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此处可以处理一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 比如访问top并记录")]),t._v("\n        result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注意这里也可以不用 for 循环，视题意而定")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// for(检查 top 元素出发能够遍历到的所有元素)  {")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// queue.push(top能够直接抵达的元素)")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// }")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果左子树存在，左子树入队")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            queue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果右子树存在，右子树入队")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            queue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"常见问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),s("h4",{attrs:{id:"岛屿问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#岛屿问题"}},[t._v("#")]),t._v(" 岛屿问题")]),t._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-islands/",target:"_blank",rel:"noopener noreferrer"}},[t._v("200. 岛屿数量"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/max-area-of-island/",target:"_blank",rel:"noopener noreferrer"}},[t._v("695. 岛屿的最大面积"),s("OutboundLink")],1)])])]),t._v(" "),s("p",[t._v("思路参考：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/")]),t._v(" "),s("h2",{attrs:{id:"递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[t._v("#")]),t._v(" 递归")]),t._v(" "),s("h3",{attrs:{id:"树递归遍历的三种方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树递归遍历的三种方式"}},[t._v("#")]),t._v(" 树递归遍历的三种方式")]),t._v(" "),s("blockquote",[s("p",[t._v("以后只要分析出"),s("strong",[t._v("重复")]),t._v("的逻辑（排除掉类似数组遍历这种简单粗暴的重复），你都需要把"),s("strong",[t._v("递归")]),t._v("从你的大脑内存里调度出来、将其列为“可以一试”的解法之一；")])]),t._v(" "),s("p",[t._v("只要想到递归，立刻回忆 "),s("strong",[t._v("DFS")]),t._v(" 思想、然后尝试套解题模板。递归思想：1.分析重复动作，确认重复的递归式；2.确认递归边界（递归终点）。")]),t._v(" "),s("h3",{attrs:{id:"常见问题类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见问题类型"}},[t._v("#")]),t._v(" 常见问题类型")]),t._v(" "),s("h4",{attrs:{id:"全排列-固定的坑位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全排列-固定的坑位"}},[t._v("#")]),t._v(" 全排列（固定的坑位）")]),t._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/permutations/",target:"_blank",rel:"noopener noreferrer"}},[t._v("全排列 I"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/permutations-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("全排列 II"),s("OutboundLink")],1)])])]),t._v(" "),s("h4",{attrs:{id:"组合问题-变化的坑位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合问题-变化的坑位"}},[t._v("#")]),t._v(" 组合问题（变化的坑位）")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/subsets/",target:"_blank",rel:"noopener noreferrer"}},[t._v("78. 子集"),s("OutboundLink")],1)])]),t._v(" "),s("h4",{attrs:{id:"限定组合问题-及时回溯-即为-剪枝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#限定组合问题-及时回溯-即为-剪枝"}},[t._v("#")]),t._v(" 限定组合问题（及时回溯，即为“剪枝” ）")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/combinations/",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"回溯"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯"}},[t._v("#")]),t._v(" 回溯")]),t._v(" "),s("blockquote",[s("p",[t._v("回溯是指一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。"),s("br"),t._v("\n回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。"),s("br"),t._v("\n“回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。”（看着有点 DFS 的意思）")])]),t._v(" "),s("h3",{attrs:{id:"递归与回溯问题-解题模板总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归与回溯问题-解题模板总结"}},[t._v("#")]),t._v(" 递归与回溯问题——解题模板总结")]),t._v(" "),s("ol",[s("li",[t._v("什么时候用（场景）")])]),t._v(" "),s("p",[t._v("（1）题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。"),s("br"),t._v("\n（2）题目经分析后，可转化为树形逻辑模型求解。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("为什么用（依据）")])]),t._v(" "),s("p",[t._v("递归与回溯的过程，本身就是穷举的过程。解是基于穷举思想、对"),s("strong",[t._v("搜索树")]),t._v("进行恰当地剪枝后得来的。")]),t._v(" "),s("blockquote",[s("p",[t._v("在深度优先搜索中，有时我们会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为“剪枝”。")])]),t._v(" "),s("p",[t._v("还有一种情况是不问解的内容，只问解的个数。这类问题往往不用 DFS 来解，而是用动态规划。")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("怎么用（实现步骤）")])]),t._v(" "),s("p",[t._v("一个模型——树形逻辑模型；两个要点——递归式和递归边界。")]),t._v(" "),s("p",[t._v("树形逻辑模型的构建，关键在于找“坑位”，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。")]),t._v(" "),s("p",[t._v("递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界。")]),t._v(" "),s("p",[t._v("根据以上规律，总结出的大概代码形式：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getResults")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("arg")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 前期初始化的准备工作")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 存储每条路径")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" path "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 进入dfs")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("起点"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("dfs")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("递归参数")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("递归边界"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            根据题意作出的边界逻辑处理"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归式，注意这里也可能不是 for，视题意决定")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("遍历每个坑位可选的值"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n          path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("当前选中值"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n          处理坑位本身的相关逻辑\n\n          path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("回溯例题：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("入门")])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/binary-tree-paths/",target:"_blank",rel:"noopener noreferrer"}},[t._v("257-二叉树的所有路径"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/",target:"_blank",rel:"noopener noreferrer"}},[t._v("17-电话号码的字母组合"),s("OutboundLink")],1)])])]),t._v(" "),s("p",[t._v("【中等】60-第 k 个排列")]),t._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/subsets/",target:"_blank",rel:"noopener noreferrer"}},[t._v("78. 子集"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/combinations/",target:"_blank",rel:"noopener noreferrer"}},[t._v("77-组合"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/combination-sum/",target:"_blank",rel:"noopener noreferrer"}},[t._v("39-组合总和"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/combination-sum-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("40-组合总和 II"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/combination-sum-iii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("216-组合总和 III"),s("OutboundLink")],1)])])]),t._v(" "),s("p",[t._v("【中等】79-单词搜索")]),t._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/permutations/",target:"_blank",rel:"noopener noreferrer"}},[t._v("46-全排列"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/permutations-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("47-全排列 II"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[t._v("熟练")])])]),t._v(" "),s("p",[t._v("【中等】332-重新安排行程")]),t._v(" "),s("p",[t._v("【困难】51-N 皇后")]),t._v(" "),s("ul",[s("li",[t._v("精通")])]),t._v(" "),s("p",[t._v("【困难】37-解数独")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/combination-sum-iv/",target:"_blank",rel:"noopener noreferrer"}},[t._v("377-组合总和 Ⅳ"),s("OutboundLink")],1),t._v(" （PS：这道题普通回溯会超时）")])])])}),[],!1,null,null,null);s.default=e.exports}}]);